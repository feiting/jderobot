%%%%%%%%%%%%%%%%%%%%%%% file template.tex %%%%%%%%%%%%%%%%%%%%%%%%%
%
% This is a general template file for the LaTeX package SVJour3
% for Springer journals.          Springer Heidelberg 2010/09/16
%
% Copy it to a new file with a new name and use it as the basis
% for your article. Delete % signs as needed.
%
% This template includes a few options for different layouts and
% content for various journals. Please consult a previous issue of
% your journal as needed.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\RequirePackage{fix-cm}
%
%\documentclass{svjour3}                     % onecolumn (standard format)
%\documentclass[smallcondensed]{svjour3}     % onecolumn (ditto)
%
%\documentclass[smallextended]{svjour3}       % onecolumn (second format)
\documentclass[twocolumn]{svjour3}          % twocolumn
%
\smartqed  % flush right qed marks, e.g. at end of proof
%
\usepackage{graphicx}
\usepackage[spanish]{babel}
% \usepackage{mathptmx}      % use Times fonts if available on your TeX system
%
% insert here the call for the packages your document requires
%\usepackage{latexsym}
% etc.
%
% please place your own definitions here and don't use \def but
% \newcommand{}{}
%
% Insert the name of "your journal" with
\journalname{Autonomous Robots}
%
\begin{document}

\title{Jderobot open source framework for robotic, computer vision and home automation applications
%\thanks{Grants or other notes
%about the article that should go on the front page should be
%placed here. General acknowledgments should be placed at the end of the article.}
}
%\subtitle{Do you have a subtitle?\\ If so, write it here}

%\titlerunning{Short form of title}        % if too long for running head

\author{First Author         \and
        Second Author %etc.
}

%\authorrunning{Short form of author list} % if too long for running head

\institute{F. Author \at
              first address \\
              Tel.: +123-45-678910\\
              Fax: +123-45-678910\\
              \email{fauthor@example.com}           %  \\
%             \emph{Present address:} of F. Author  %  if needed
           \and
           S. Author \at
              second address
}

\date{Received: date / Accepted: date}
% The correct dates will be entered by the editor


\maketitle

\begin{abstract}
Insert your abstract here. Include keywords, PACS and mathematical
subject classification numbers as needed.
\keywords{First keyword \and Second keyword \and More}
% \PACS{PACS code1 \and PACS code2 \and more}
% \subclass{MSC code1 \and MSC code2 \and more}
\end{abstract}

\section{Introduction}
\label{intro}

%software importance
Most of robot intelligence lies on its software. Once the robot sensor and actuator devices are set, the robot behavior is fully caused by its software. There is no universally accepted way of programming robots.Regarging the language, there are robots programmed in assembler, in C and C++ or in Java. 

The importance of good programming practices has increased in last years. Code reuse to avoid restart from scratch for every new robot. JOSER, ieee chapter, autonomous robots special issue. Software enginering.

Encapsulating robot capabilities in functions is a slippery issue as behaviors usually don't fit into the functional abstraction where the caller invoques the function and stops it flow of execution until receives the function response or output.

Simulators are useful tools in robotics.

Operating systems and robotic frameworks.

% software requirements in robotics
Compared with other computer science fields the development of robot applications exhibits some specific requirements. First, liveliness and real-time processing: software here has to take decisions with in a fast way, for instance in robot navigation or image processing. Second, robot software has to deal with multiple concurrent sources of activity, and so tends to be multitask. Third, computing power is usually distributed along several connected computers, and so the robotic software may be distributed. Fourth, the robotic software tipically deals with heterogeneous hardware. New sensor and actuator devices continually appears in the market and this makes maintenance and portability to new robots or devices more complex. Fifth, the robotic software usually includes a Graphical User Interface, mainly for debugging purposes. Sixth, the robotic software should be expansible for incremental addition of new functionality and code reuse.

% robotic frameworks 
Mobile robot programming has evolved significantly in recent years, and two approaches are currently found. On one hand, application programs for simple robots obtain readings from sensors and send commands to actuators by directly calling functions from the drivers provided by the seller. On the other hand, we have identified many common features across commercial and non-profit robotic frameworks SDKs.

First, they offer a simple and more abstract access to sensors and actuators than the operating systems of simple robots. For example, in a Pioneer with a laser rangefinder, the applications can obtain readings using ARIA or directly through a serial port. Using ARIA, one need only invoke a method and ARIA will take charge of refreshing the variables. Using the operating system directly, the application must request and periodically read the data from the laser through the serial port, and must identify the protocol of the
device to compose and analyze the low level messages correctly. The abstract access is also offered for actuators.

Second, the software architecture of the SDK sets the way the application code obtains sensor data, commands the motors, or uses a developed functionality. There are many software options: calling to library functions, reading variables, invoking object methods, sending messages via the network to servers, etc.. Depending on the programming model the robot application can be considered an object collection, a set of modules talking through the network, an iterative process calling to functions, etc.

Third, usually the SDK includes simple libraries, tools and common use functionality, such as robust techniques for perception or control, localization, safe local navigation, global navigation, social abilities, map construction, etc. The robot manufacturers sell them separately or include them as additional value with their own SDK. For example, ERSP includes three packages in the basic architecture: one for interaction, one for navigation and another for vision. There are several advantages of using the SDKs. First, they favor the portability of applications between different robots. Second, they promote code reuse, shortening the development time and reducing the programming effort needed to code the application as long as the programmer can build the program by reusing the common functionality, keeping herself focused in the specific aspects of her application. And third, the software architecture offers a way to organize code, allowing the handling of code complexity when the robot functionality increases.

% our proposal
We present our open-source robotic software framework, named Jderobot (http://jderobot.org), which is component oriented, uses ICE as communication middleware and includes several useful tools and libraries. Several sensor and actuator drivers have been programmed or reused from the open-source community. This framework has been widely used in our group for research and teaching for more than eight years. Jderobot has been designed for scenarios with sensors, actuators and intelligent software in betwween. The typical scenario is robotics, but also computer vision and home automation.

% open source
Why open-source in robotics? First, it provides independence of robot manufacturers and so it may support robots from different companies. Using open-source you are free to modify, debug, or improve the software, so the final software quality is high and does not depend on a company. One strong motivation is also the feeling of contributing to the robotics community and to return the favor. We have extensively used open-source libraries and tools in our research (OpenCV, Gazebo, GTK, etc.). Research algorithms can be replicated easily and compared with standard tools. The tools must be open in order to trust in them.

% paper organization
This paper is organized as follows. The state of the art in robotic frameworks fills section \ref{sec:relatedworks}, where other platforms are briefly presented. Section \ref{sec:jderobot} fully explains the proposed platform, the ideas behind its design, the set of standarized interfaces and developed drivers and the tools included for easing the development of new applications. In section \ref{sec:research} some succesfull examples using Jderobot are presented, both in research and in teaching. Finally conclusion section summarizes the main remarks.

\section{Related works}
\label{sec:relatedworks}

%%david
drivers, software platforms and applications.

ROS, ORCA, Miro, RoboComp, Aria, PlayerStage \cite{Gerkey03,vaughan2007}.

Microsoft Robotics Studio, Beesoft. ERSP.

\section{Jderobot platform}
\label{sec:jderobot}

Some history. Keep away the cognitive ideas, focus on software architecture. Nace como implementación de arquitectura cognitiva, tesis doctoral. Evolucionó a una plataforma de programación para aplicaciones robóticas, domóticas y de visión computacional (sensores, actuadores, inteligencia).

\begin{itemize}
\item Orientada a componentes distribuidos y multilenguaje
\item La mantiene un grupo de desarrolladores, es abierta
\item {http://jderobot.org}, manuales, descarga, ejemplos
\end{itemize}
Software libre (licencia GPLv3), paquete debian


Arquitectura cognitiva JDE:
\begin{itemize}
\item Comportamiento = {percepción} y {control}
\item Fragmentación en unidades asíncronas concurrentes (esquemas)
\begin{itemize}
\item[-] de percepción elaboran estímulos
\item[-] de actuación toman decisiones
\end{itemize}
\item La colección de esquemas se organiza en \textit{jerarquía} dinámica (JDE)
\item Sigue el paradigma basado en comportamientos
\end{itemize}

Arquitectura cognitiva: Esquemas.
Un {esquema} es un flujo de ejecución independiente, con un objetivo
\begin{itemize}
\item Funcionamiento continuo
\item Se puede activar y desactivar a voluntad
\item Modulable a través de parámetros
\item Su funcionalidad se usa despertándolo y modulándolo
\item {Perceptivos}: producen estímulos (piezas de información) y los mantienen actualizados. Lecturas sensoriales, transformaciones más elaboradas 
\item {Actuación}: toman decisiones para conseguir o mantener un objetivo, comandos a los actuadores o la activación y modulación de otros 
\end{itemize}














\subsection{Software architecture design}

Some history and lessons learnt: 4.3. 

Threads. GUI specific interface. 

\begin{itemize}
\item Component oriented 
\item Iterative execution
\item Concurrent and optional visualization
\item Processes better than threads
\item ICE for communication
\item Explicit standard interfaces
\item Configuration files 
\end{itemize}

multilanguage, distributed intermachine, Android, efficient

Reuse other open-source libraries: OpenCV, Gearbox, GTK, PCL, OpenGL, PlayerStage, Gazebo, GSL, Cwii.


GUI thread separated from control thread.
Iterative control, iterative perception. Component frequency.
Standard interfaces for communication with other components.

Modelo de programación: Componente
\begin{itemize}
\item Cada esquema se materializa en un {componente} software 
\item El funcionamiento continuo como {ejecución iterativa}, iteraciones periódicas a cierto ritmo para percibir o para actuar
\item Ofrece funcionalidad y usa la de otros a través de {interfaces} explícitos
%el componente es la unidad básica
\item Aplicación $=$ conjunto de componentes concurrentes que interoperan
\item {Multimáquina} y {multilenguaje}: C, C++, python, Java... 
\item Usa el middleware de comunicaciones ICE (zeroC)
\end{itemize}

Ejecución iterativa:
\begin{itemize}
\item Iteración de control o de percepción
\item component\_cycle 
\item \texttt{gettimeofday}
\item \texttt{usleep}
\item Espera condicional
\item Patrón de diseño \textit{Algoritmo iterativo}
\end{itemize}

Interfaces tipados
\begin{itemize}
\item {Comunicación entre componentes}, conexión con otros 
\item Fijan la estructura de los datos que el componente ofrece o necesita
%\item Invocar funciones del interfaz
\item Cada componente puede necesitar y ofrecer uno o varios interfaces 
%espacio de nombres
\item Se definen con \texttt{slice}
\item Generación de código para múltiples lenguajes (C++, Java, Python...)
\item Mecanismos de transmisión de datos eficientes
\begin{itemize}
\item transmisión síncrona o asíncrona
\item publicación/subscripción
\end{itemize}
\end{itemize}


Visualización
\begin{itemize}
\item {Modular} y {opcional}: cada componente tiene (o no) su propio GUI
\item Cada componente incluye el código de su interfaz gráfica
%\item Activable/desactivable a voluntad, cuando interesa
\item Mostrar e interacción con humano 
\item Depuración, útil en desarrollo
\item GTK, XForms, OpenGL
\item Patrón de diseño \textit{Modelo Vista Controlador}
\item Se materializa en una {hebra adicional}
\end{itemize}



Ficheros de configuración:
\begin{itemize}
\item Cada componente puede tener el suyo 
\item Ficheros de configuración ICE
\item Especifican cuál es la fuente de cada interfaz (local o remota)
\item Parámetros específicos
\end{itemize}

\subsection{Interfaces and drivers}


Acceso a los dispositivos hardware
\begin{itemize}
\item Se da a través de {componentes drivers}
\item Acceden localmente al sensor/actuador y ofrecen acceso (local o remoto) a otros a través de interfaces ICE
\item No suelen tener GUI
\item El mismo interfaz de datos lo puede proporcionar varios \textit{drivers}
\begin{itemize}
\item Mismo programa funciona sobre robot real o simulador
\item Independencia de la fuente de imágenes
\end{itemize}
\end{itemize}


Standard interfaces. 
PlayerServer, GazeboServer for Gazebo Simulator \cite{koening2004}, NaoServer, KinectServer, OpenNIServer, giraffeServer, PTU, Hokuyo, Wiimote, CameraServer.

Same interfaces for different robots.
Applications run exactly the same on real robot than on simulator. 

\subsection{Tools and libraries}

\subsubsection{FuzzyLib}: control borroso
\subsubsection{VisionLib}: geometría espacial, analisis de imágenes 
\subsubsection{Progeo}: relacionar las imágenes con 3D, cámaras calibradas 
\subsubsection{Colorspaces}: espacios de color para imágenes

\subsubsection{Control template}
Basic component for reactive controllers
\subsubsection{VisualHFSM}
\subsubsection{Calibrator}
\subsubsection{ColorTuner}
\subsubsection{Recorder and replayer}

When we use real robots, one of the greatest difficulties is repeating experiments with the same conditions, whether we want to compare different algorithms or to test several features of the same algorithm. It's almost impossible to reproduce the same environment conditions, since robot hardware behaves diversely, light conditions change if we use cameras, people or objects move or are located in different places, etc.

To avoid all these matters, we have designed a new tool which records the current devices status and reproduces them whenever we want to. There are two components involved in this tool, the first one is the so-called "recorder", it saves in a file the status of all the devices of the robot, such as odometry, laser measures, image cameras, etc; we can configure which devices we want to track when we executes the components and it works with simulators, real Nao robots and real Pioneer robots.

The second components is the "replayer" component, it reads the file saved by the "recorder" component and provides the same ICE interfaces that would provide the real devices. Thus, when an algorithm gets the current devices status, it can't tell if it's obtaining the current devices measures in real time or pre-recorded data.

This tools has been widely used to perform experiments with real robots, to try different parameters and improve our algorithms.

\subsubsection{Gazebo}

Gazebo.

\section{Research and Teaching}
\label{ref:research}
In an effort to stimulate young people to get involved with technology, robots seem a topic that attracts interest.

When allowing students to design, build and program their own robots, they will get involved in many technical activities that also overlap with several other disciplines like Mathematics, Engineering, Electronics, Information Technology and Science in general.

Also they will learn to work in teams and will be faced with many difficult technical decisions which enhance their management skills.

\subsection{The lessons}

When setting up lessons there always is a challenge about how complicated the lessons should be. Special Jderobot components have been developed for students, in which a number of pre-programmed instructions are used to let students construct their own applications.

Such an approach eliminates the need to know a lot about gears, motors, using sensors, calibration and allows students to have a working robot within little over an hour.

The most important issue with the project is of course to interest students to get involved with technology. So it must be made very simple and yet interesting. It is very important that students can get their first results quickly, so they learn that they can master working with robots. This approach seems to facilitate this.

\subsection{Basic component}

Starting with a basic component like Introrob is very stimulating. Once the enthusiasm has been generated, they still need to learn about motors, sensors, control issues and programming.

So it becomes important to offer a migration path from this very simple starting level to an environment where more skills are required. The best way is to start with a simple level and have a programming environment, such as Jderobot, that supports working from the very simple to a slightly more advanced level.

\subsection{Simulator and servers}

Having an integrated simulator is very important, so the students may quickly test their experiments without the need for a robot for every student. Such an environment is provided by The Player Project\footnote{http://playerstage.sourceforge.net/index.html}. This Open Source software is capable of simulating a population of robots, sensors and objects, but does so in a three-dimensional world.

Jderobot integrates two servers, named PlayerServer and GazeboServer, which are used to communicate Player and Gazebo simulators with other software components in the Jderobot platform. It's possible to retrieve information from several sensor devices, such us: laser, encoders, motors, cameras or sonars. And it also supports one or more cameras with their pantilt units (SonyVid30 model).

\subsection{Libraries}

To facilitate the use of certain geometry functions, which are used in performing points and lines model configuration, Jderobot provides a library called ProGeo. It is useful to do camera operations such as: calibration, 2D to 3D transformation and viceversa and so on.

Furthermore, lots of mathematical functions used on visual perception purposes can be found on another library: VisionLib. This vision library contains computer vision research code initially developed to support the RobotVision project. It has since been expanded to provide a range of software infrastructure for computer vision, geometry models and images mechanisms. The library builds on top of the OpenCV Computer Vision Library\footnote{http://opencv.willowgarage.com/wiki} and the GNU Scientific Library\footnote{http://www.gnu.org/software/gsl} (GSL). 

\subsection{Android mobileTeleoperator}

Android operating system is increasing its market share every day, both with smartphones and tables. Once you develop an application for this platform, it may be used by students, other researchers or even companies. 

We have created an application called "Mobile Teleoperator" to teleoperate either a Pioneer robot with playerserver or a Nao Robot with BICA architecture. Connection among the mobile device and the robots is made through ICE, the same way we do when we use a standard computer, so we don't need to change anything in Jderobot architecture.

There are three ways to teleoperate the robots:
- Arrows: After pressing a button, it sends the command to the robot and the robot keeps his behavior until the stop button is pressed.
- Joystick: While a button is pressed, it send the command to the robot, but if the button is released it sends a stop command automatically.
- Accelerometer: It uses the mobile accelerometers to command the robot depending on our device orientation. To use this behavior you must keep a "safety" button pressed, this button is used to calibrate the accelerometers when it is pressed the first time and to send a stop command automatically once this button is released.

Mobile teleoperator has been used to create demonstrations and to let people who are not used to control robot to teleoperate robots in a easy way.

\subsection{Navigation algorithms}
Navigation algorithms
\subsection{Selflocalization algorithms}

Self-localization is at the moment one of the most important challenges in robotics. Using robot sensors, such as cameras, laser sensors or ultrasonic sensors, our robot must be able to calculate its own localization inside an environment. Once the robot knows its position, it can adapt its behavior depending on where it is located. 
 
However, robot self-localization has proven to be one the most complex task on mobile robots, since they must face unknown situations, such as occlusions, or being located inside a dynamic environment.

With Jderobot, we have designed and implemented plenty of localization algorithm, since classical localization algorithms such as Monte Carlo particle filters or Kalman filters, to new and improved algorithms such as evolutionary algorithms or MonoSLAM.

\subsubsection{MonoSLAM}

Monocular Simultaneous Localization And Mapping (MonoSLAM) is a type of localization first presented by Andrew J. Davison in 2003 (ref). MonoSLAM is able to construct a point-based map of the environment with a single camera, and localizates the camera inside this environment in real time.

We have developed our own MonoSLAM approach, based on Davison work, obtaining images from real cameras and simulators. We have implemented the point-based approach designed by Andrew Davison and afterwards we have designed our own implementations based on points and lines.

This type of localization is more accurate than classical localization methods and is very useful when robot odometry is not available or is not reliable. On the other hand, it is not able to handle occlusions and needs a faster frame rate.

% For two-column wide figures use
\begin{figure*}
% Use the relevant command to insert your figure file.
% For example, with the graphicx package use
  \includegraphics[width=7cm]{figs/programacion3.jpg}
% figure caption is below the figure
\caption{Please write your figure caption here}
\label{fig:2}       % Give a unique label
\end{figure*}


\section{Conclusions}

Jderobot, open source project
\begin{itemize}
\item Más de 60000 líneas de código
\item Comunidad de usuarios y desarrolladores
%\item Aumentar la calidad del software
\item ¿Dónde conseguirla? ¿Cómo preguntar dudas? 
\item Página web: {http://jderobot.org}
\item Listas de correo: jde-users@gsyc.es y jde-developers@gsyc.es
\item Svn, trac, blog, mediawiki
\item Paquete debian: \texttt{apt-get install jderobot}
\end{itemize}

\begin{acknowledgements}
Funding agencies. Alex, Maikel, Fran.
\end{acknowledgements}

% BibTeX users please use one of
\bibliographystyle{spbasic}      % basic style, author-year citations
%\bibliographystyle{spmpsci}      % mathematics and physical sciences
%\bibliographystyle{spphys}       % APS-like style for physics
\bibliography{bibliografia}   % name your BibTeX data base


\end{document}


