%Introducción
\newpage 
\section{Introducción}

La robótica es una materia multidisciplinar donde confluyen muchos campos: la mecánica, la electrónica, la inteligencia artificial, el control automático e incluso la etología o la psicología. Una de las ramas más interesantes es la robótica móvil, en concreto la generación de comportamiento autónomo dentro de los robots móviles. El objetivo que persigue la robótica móvil es conseguir que las máquinas hagan tareas autónomamente con la flexibilidad y robustez que exhibe el ser humano realizándolas.

%robot=sensores+actuadores+procesadores
Hay muchos tipos de robots: con ruedas, con patas, brazos robotizados, con forma humanoide, con forma cilíndrica, etc. La morfología no es una característica esencial. Lo que identifica a cualquier robot es que combina en la misma plataforma a sensores, actuadores y procesadores. Los \textit{sensores} miden alguna característica del entorno o propia (p.e. cámaras, sensores de obstáculos, etc). Los \textit{actuadores} permiten al robot hacer algo, llevar a cabo alguna acción o simplemente desplazarse (p.e. los motores). Los \textit{procesadores} hacen los cómputos necesarios y realizan el enlace entre sensores y actuadores, materializando el comportamiento del robot en el entorno en el cual se encuentra inmerso. 

%generar inteligencia = programar al robot
%el software de robots tiene ciertas características genuinas
%programar robots != mainstream software
En la práctica, una vez construido el cuerpo mecánico del robot, el comportamiento autónomo se convierte en un problema de programación. Generar comportamiento en un robot consiste en escribir el programa que causa ese comportamiento al ejecutarse en el robot cuando éste se encuentra en cierto entorno. Sin embargo, escribir programas para robots móviles es una tarea complicada, ya que los robots son sistemas complejos. La programación de robots móviles suele ser más exigente que la creación de programas tradicionales como aplicaciones de ofimática, bases de datos, etc. 

%sensores y actuadores
%vivacidad
Por ejemplo, los programas de robots móviles están directamente conectados a la realidad física a través de sensores y actuadores. Esta situación implica que el software debe ser ágil, tomar decisiones con vivacidad para controlar correctamente a los actuadores. Por esta razón, se requiere de actuación en tiempo real, si no estricto, al menos blando.

% multitarea -> concurrencia
Una aplicación de robots móviles típicamente debe estar pendiente de varias fuentes de actividad y objetivos a la vez. El programa de un robot tiene que atender a muchas cosas simultáneamente: recoger nuevos datos de varios sensores, refrescar la interfaz gráfica, enviar periódicamente consignas a los motores, enviar o recibir datos por la red a otro proceso de la aplicación, etc. Por ello estas aplicaciones suelen ser concurrentes, lo cual les añade cierta complejidad. 

%heterogeneidad, no hay un escenario nítido
Además, los programadores de robots se enfrentan a una creciente heterogeneidad que dificulta su tarea. En cuanto al hardware, existe una gran diversidad de dispositivos sensoriales y de actuación, y por lo tanto de interfaces. El programador debe dominarlos para acceder a ellos desde las aplicaciones. Por otro lado, mientras que en muchos campos de la informática sí hay bibliotecas que un programador puede emplear para construir su propio programa, en el software de robots no hay un marco homogéneo ni hay estándares que propicien la reutilización de código \cite{utz02,montemerlo03,cote04} y la integración. En robótica cada aplicación prácticamente ha de construirse desde cero para cada robot concreto.

\subsection{Robots y entornos de programación}

%programación ad-hoc
Antiguamente los programas de control de robots se solían construir empleando directamente los \textit{drivers} para acceder a sus sensores y actuadores. Como muestra la figura \ref{fig:progjde}, el programa recogía las medidas obtenidas por los sensores y ordenaba los comandos de movimiento a los motores invocando las funciones de librería que ofrecía el fabricante en sus \textit{drivers}.

\begin{figure}[htb]
\begin{center}
\begin{tabular}{c@{\hspace*{2.cm}}c}
\includegraphics[width=6cm]{figs/programacion3} &
\includegraphics[width=6cm]{figs/programacion2}\\
\end{tabular}
\end{center}
\caption{Programación clásica de robots sobre \textit{drivers} específicos de sensores y actuadores, y programación sobre una plataforma de desarrollo}
\label{fig:progjde}
\end{figure}

Actualmente las aplicaciones con robots presentan cada vez mayor complejidad y ofrecen mayor funcionalidad. En muchos campos del software se ha ido implantando \textit{middleware} que simplifica el desarrollo de nuevas aplicaciones en esas áreas. Este \textit{middleware} proporciona contextos nítidos, estructuras de datos predefinidas, bloques muy depurados de código de uso frecuente, protocolos estándar de comunicaciones, mecanismos de sincronización, etc.. Del mismo modo, a medida que el desarrollo de software para robots móviles ha ido madurando han ido apareciendo diferentes plataformas \textit{middleware} \cite{utz02}.

Hoy en día los fabricantes más avanzados incluyen plataformas de desarrollo para simplificar a los usuarios la programación de \textit{sus} robots. Por ejemplo, ActivMedia ofrece la plataforma ARIA \cite{activmedia02} para sus robots Pioneer, PeopleBot, etc.; iRobot ofrecía Mobility \cite{rwi99} para sus B14 y B21; Evolution Robotics vende su plataforma ERSP; y Sony ofrece OPEN-R \cite{martin04} para sus Aibo.
% Otros fabricantes menos avanzados carecen de plataforma de desarrollo
% u ofrecen una muy limitada.
Además de los fabricantes, muchos grupos de investigación han creado sus propias plataformas de desarrollo. Varios ejemplos son la suite de navegación \htlink{CARMEN}{http://www-2.cs.cmu.edu/~carmen} \cite{montemerlo03} de Carnegie Mellon University, Orocos \cite{bruyninckx01}, \texttt{Player/Stage/Gazebo} (PSG) \cite{gerkey03,vaughan03}, Miro \cite{utz02}, JDE \cite{canas02}, MARIE \cite{cote04}, etc..
%Mientras los fabricantes buscan que su plataforma sirva para sus modelos, los grupos de investigación aspiran a una mayor universalidad y sus plataformas tratan de incluir soporte para los robots de sus laboratorios, típicamente de diferentes fabricantes.

%objetivos de la plataforma
El objetivo fundamental de estas plataformas es hacer más sencilla la creación de aplicaciones para robots y ocultar o atenuar la heterogeneidad ya mencionada. Hemos identificado varias características comunes entre ellas: uniforman y simplifican el acceso al hardware, ofrecen una arquitectura software concreta y proporcionan un conjunto de bibliotecas o módulos con funciones de uso común en robótica que el cliente puede reutilizar para programar sus propias aplicaciones.

\subsection{Plataforma jdec}
%vistazo global a toda la plataforma

Una de esas plataformas es \textit{jdec}, fruto de una tesis doctoral sobre generación de comportamientos autónomos en robots móviles \cite{canas03}. Históricamente surge en 1997 y desde entonces ha ido evolucionando e incorporando nuevas funcionalidades. Hoy día es una plataforma de referencia para la investigación del grupo de Robótica-URJC y para la docencia de robótica en la Universidad Rey Juan Carlos.

\subsubsection{Acceso a los sensores y actuadores}
%acceso a los sensores y actuadores
\label{sec:sensact}
En cuanto al acceso a sensores y actuadores, \textit{jdec} ofrece un conjunto de variables perceptivas y de actuación respectivamente. La aplicación robótica obtiene las últimas observaciones sensoriales leyendo las variables perceptivas, que la plataforma mantiene permanentemente actualizadas. La aplicación robótica ordena comandos a los motores escribiendo en las variables de actuación, que la plataforma se encarga de materializar y hacer llegar hasta los actuadores correspondientes. La plataforma \textit{jdec} mantiene activo este interfaz de variables y la aplicación robótica se sitúa encima, leyendo continuamente los datos sensoriales de ese API y escribiendo en él los comandos motores que determina en cada momento. Este API de variables contrasta con la abstracción funcional de otras plataformas. 

\begin{figure}[htb]
\begin{center}
\includegraphics[width=9cm]{figs/jdebasico}
\end{center}
\caption{Programación sobre jdec}
\label{fig:jdeglobal}
\end{figure}

%fuentes del hardware
Esas variables han de conectarse a los dispositivos del robot, ya sean reales o simulados. Esta conexión se determina en un fichero de configuración que especifica donde está la fuente final las variables perceptivas y el destino final de las variables de actuación. Esto permite ejecutar literalmente la misma aplicación dentro del mundo real o del simulador sin más que cambiar ese fichero de configuración de una ejecución a otra.  Este acceso a los sensores está implementado por los drivers (ver sección \ref{subsec:drivers}) que realizan el refresco de las variables sensoriales y trasladan al hardware los efectos de las variables actuadoras.

Como ilustra la figura \ref{fig:jdeglobal}, \textit{jdec} permite tres posibles configuraciones típicas:
\begin{enumerate}
\item Los sensores y actuadores del robot real pueden estar físicamente conectados al ordenador en el que se ejecuta \textit{jdec}. Por ejemplo, con la base motora del pioneer conectada al puerto serie del ordenador portátil, y el par de cámaras a su bus firewire. La plataforma incorpora los \textit{drivers} oportunos para resolver el acceso local a esos dispositivos.
\item Los sensores y actuadores pueden estar simulados y \textit{jdec} se conecta al simulador.
\item \textit{jdec} se conecta a los \textit{servidores de red} que a su vez están finalmente enlazados con los dispositivos hardware locales o con un simulador. La ventaja de usar estos servidores es que los dispositivos y la aplicación robótica no tienen que estar necesariamente en la misma máquina.
\end{enumerate}

Como veremos en la sección \ref{subsec:drivers}, la misma variable se puede conectar a diferentes dispositivos del mismo tipo. Por ejemplo, la misma variable para imágenes se puede conectar a una cámara firewire, a una webcam USB o a una cámara analógica enchufada a una tarjeta digitalizadora. La plataforma incorpora los \textit{drivers} necesarios para cada caso y en todos los casos las imágenes llegan a la aplicación a través de la misma variable exactamente. De esta manera se uniforma el acceso y la plataforma amortigua parte de la heterogeneidad del hardware, que no afecta tanto al código de las aplicaciones.

%\vspace{0.5cm}
\subsubsection{La aplicación robótica es una colección de esquemas}
%modelo de esquemas concurrentes
En cuanto a la arquitectura software concreta, dentro de \textit{jdec} las aplicaciones robóticas se conciben y organizan como un conjunto de esquemas concurrentes. Un \textit{esquema} no es más que una hebra con cierto objetivo, que se ejecuta iterativamente a un ritmo controlado. Para aplicaciones reactivas sencillas, probablemente con un único esquema que tenga muchas iteraciones por segundo resulte suficiente.

Para aplicaciones algo más complejas \textit{jdec} propone dividir la funcionalidad en esquemas perceptivos y esquemas de actuación concurrentes, todos al mismo nivel. Los esquemas perceptivos tratan los datos sensoriales y elaboran nueva información, que se ofrece a los demás esquemas como nuevas variables compartidas. Los esquemas de actuación recogen la información sensorial o de otros esquemas perceptivos y toman decisiones de actuación.

Para aplicaciones aún más complicadas \textit{jdec} propone organizar la colección de esquemas en una jerarquía de varios niveles, donde unos activan a otros. De hecho los esquemas se inicializan, se modulan durante su ejecución, se pueden detener y relanzar a voluntad. Aquí la novedad de esta plataforma es que no se encapsula la funcionalidad en un conjunto de funciones que se invocan, sino en un conjunto de esquemas concurrentes que se activan y modulan entre sí. Esta división software tiene su sustrato teórico en la arquitectura cognitiva JDE \cite{canas03} para generar comportamiento autónomo en robots.

%Para qué es útil
\subsubsection{Usos de la plataforma \textit{jdec}}

La plataforma \textit{jdec} originalmente se utilizó para la programación del robot Pioneer (ver figura \ref{fig:dospioneers}). Para facilitar la programación y la implementación de nueva funcionalidad se estandarizó el acceso a los sensores y actuadores del robot. De esta forma el programador sólo tenía que preocuparse del comportamiento. Poco a poco la plataforma se fue generalizando, así se descentralizó el soporte del hardware, de esta forma se pueden reutilizar los programas para diferentes robots simplemente generando soporte para el hardware específico. Actualmente se puede utilizar la plataforma para programar cualquier robot que utilice cómo sistema operativo GNU/Linux.

Otro posible uso es en la domótica. Una vez más al estar descentralizado el soporte hardware podemos generar nuestros propios drivers para dar soporte al hardware específico que se vaya a utilizar.

Por último se está usando \textit{jdec} para aplicaciones de visión computacional. La plataforma generaliza el acceso a las imágenes, de esta forma el programador puede pasar directamente a realizar sus algoritmos sin preocuparse por las fuentes de vídeo que se puedan llegar a utilizar.

\begin{figure}[htb]
\begin{center}
\includegraphics[width=6.5cm]{figs/pioneer-stereo}
\end{center}
\caption{Robot Pioneer con cámaras, el primer robot que soportó la plataforma}
\label{fig:dospioneers}
\end{figure}
 
\subsection{Contexto software de jdec}

%nicho al que se dedica: pc, lenguaje C y linux

%PC
En primer lugar, \textit{jdec} está orientada a robots con ordenadores personales (portátiles, de sobremesa, empotrados...) como procesadores principales. Esta decisión coincide con la proliferación de los PCs en los robots de centros de investigación, que se explica por su precio asequible, su crecimiento continuo en la velocidad de cálculo y por las abundantes herramientas de programación disponibles para ellos.

%linux
En segundo lugar, \textit{jdec} funciona sobre el sistema operativo \texttt{GNU/Linux}. Además de ser el más usado por los autores, tiene detrás una comunidad muy activa y amplia de desarrolladores, lo cual garantiza en la práctica la incorporación del soporte de los nuevos dispositivos hardware que van ofreciendo los avances tecnológicos. Otras ventajas son que es software libre y que la actualización del sistema es muy sencilla. Además, ofrece un amplio abanico de aplicaciones y herramientas de programación. Aunque no ofrece tiempo real \textit{duro} resulta suficientemente ágil para nuestras aplicaciones robóticas.

%lenguaje C
En tercer lugar, el lenguaje C es el elegido para desarrollar \textit{jdec} y las aplicaciones sobre ella. Este lenguaje supone un buen compromiso entre potencia expresiva y rapidez. Como lenguaje compilado su eficiencia temporal es superior a otros lenguajes interpretados. Además gran parte del software proporcionado por los fabricantes de robots y por muchos grupos de investigación está escrito en este lenguaje. La reutilización o integración de software es más factible en este lenguaje común. Recientemente se puede observar en la comunidad robótica un crecimiento de los desarrollos en C++. Una ventaja es que la portabilidad desde C a C++ es relativamente sencilla.

%multitarea, interfaz gráfico y comunicaciones
Finalmente hemos elegido varias bibliotecas sobre las que apoyar el código de \textit{jdec}, con el criterio de que fueran suficientes, estables y ampliamente usadas. Para materializar las hebras de las aplicaciones robóticas hemos elegido la biblioteca \textit{Pthreads}. Para programar las interfaces gráficas, la biblioteca \texttt{GTK} y la biblioteca \texttt{Xforms} \cite{zhao00}, que se monta encima de Xlib, dentro del sistema de ventanas \texttt{X-Window}. Y para las comunicaciones entre procesos ejecutando en máquinas diferentes hemos elegido la biblioteca de \textit{sockets} de GNU/Linux.

\newpage 
\section{Instalación}
\label{sec:instalacion}

Actualmente \texttt{jdec} está organizado de forma jerárquica mediante plugins. Existen esquemas y drivers. Los drivers proporcionan un acceso simplificado a los sensores y actuadores para la aplicación. Los esquemas (schemas) son las aplicaciones de usuario.
Tanto unos como otros se cargan de forma dinámica al lanzar la plataforma según indique el fichero del directorio actual \texttt{jde.conf}, o el especificado como argumento.

\subsection{Descarga}
La última versión de \texttt{jdec} siempre está disponible en línea mediante \textit{subversion}. Para descargarla se necesita un cliente de \textit{subversion}, que podemos obtener así:
      \begin{verbatim}
      apt-get install subversion
      \end{verbatim}
Una vez que se dispone de cliente subversion, para descargar la última versión de \texttt{jdec} basta ejecutar:
      \begin{verbatim}
      svn co http://svn.robotica-urjc.es/jde/jdec/trunk <directorio_destino>
      \end{verbatim}
Para más información acerca de \texttt{jdec} puedes visitar su página (repara en el https://):
      
      \vspace{5 mm}
      
      \texttt{https://trac.robotica-urjc.es/jde/}
      
      \vspace{5 mm}

Una vez descargado se puede actualizar la copia de trabajo sin necesidad de descargarla completamente, utilizando el comando de svn (es recomendable consultar el manual de svn para más información):
    \begin{verbatim}
      svn update
    \end{verbatim}

\subsection{Descripción de drivers y esquemas}
\subsubsection{Drivers}
En esta sección ofrecemos una versión resumida de lo que proporciona cada driver. Para más información consulta la sección de configuración.
   \begin{enumerate}
      \item \textit{firewire}: este driver nos proporciona acceso a las imágenes de las cámaras conectadas en el bus firewire (ieee1394), hasta un total de 4 cámaras.
      \item \textit{imagefile}: este driver permite cargar imágenes en formato \textit{.ppm} para trabajar con ellas en la plataforma.
      \item \textit{networkclient}: este driver permite acceder de forma remota a sensores y actuadores servidos por cierta máquina o proceso que tiene acceso a ellos.
      \item \textit{networkserver}: este driver permite a otras máquinas o procesos usar los sensores y actuadores a los que tiene acceso.
      \item \textit{pantilt}: este driver proporciona acceso al cuello mecánico del robot.
      \item \textit{player}: este driver conecta con la aplicación player, que nos da acceso a un robot simulado con \textit{stage} o real.
      \item \textit{mplayer}: este driver nos permite importar las imágenes desde vídeos y nos da acceso a las imágenes de las cámaras conectadas mediante usb así como mediante digitalizadoras o incluso permite importar imágenes desde capturadoras de televisión.
      \item \textit{graphics\_xforms}: permite obtener soporte para cargar en la plataforma interfaces gráficos creados con xforms.
      \item \textit{graphics\_gtk}: permite obtener soporte para cargar en la plataforma interfaces gráficos creados con gtk.
   \end{enumerate}
\subsubsection{Schemas}
   \begin{enumerate}
      \item \textit{hsvtuner}: este esquema es un ejemplo de como trabajar sobre imágenes y hacer un filtro de color.
      \item \textit{introrob}: este esquema es el utilizado en las asignaturas de \textit{robótica} e \textit{introducción a la robótica}. Permite una programación sencilla del robot para desarrollar algoritmos de navegación simplemente editando el archivo \texttt{navegacion.c}.
      \item \textit{myschema}: esquema sencillo para observar la estructura básica de un esquema.
      \item \textit{opengldemo}: este esquema es una demostración de opengl, podemos mover una cámara y observar objetos sintéticos en 3D generados con esta librería. Sirve como ejemplo para ver algunas posibilidades de OpenGL.
      \item \textit{recorder}: este esquema permite grabar en vídeo imágenes que exporten otros esquemas en formato bgr24 o bgr32.
   \end{enumerate}

\subsection{Compilación e instalación}
   \subsubsection{Seleccionar esquemas y drivers}
      Antes de nada hay que seleccionar los esquemas y drivers de interés. Para ello hay que editar el fichero \textit{Makefile} que se encuentra en el directorio en el que se ha descargado \texttt{jdec}. En las lineas:

      \begin{verbatim}
DRIVERS = firewire imagefile pantilt player video4linux networkclient\
          networkserver graphics_gtk graphics_xforms
SCHEMAS = hsvtuner opengldemo myperceptive introrob
      \end{verbatim}

      Dejamos únicamente aquellos elementos que vayamos a necesitar. De esta forma, compilaremos únicamente los que hemos dejado. Más adelante, podríamos compilar manualmente cualquiera de ellos si lo deseásemos.
      
   \subsubsection{Resolver dependencias}
      Antes de compilar, hay que asegurarse de que en nuestra máquina estén instalados y disponibles todos los paquetes de los que depende tanto la plataforma, como los drivers y schemas que se vayan a utilizar.
      \vspace{5 mm}

      Para instalar los paquetes necesarios en Ubuntu:
      \begin{verbatim}
sudo aptitude update
sudo aptitude install <paquetes>
      \end{verbatim}

      \begin{enumerate}
      \item \textit{Dependencias de la plataforma}: Son necesarias las cabeceras del núcleo. Para conseguirlas:
      \begin{verbatim}
sudo apt-get install linux-headers-`uname -r`
      \end{verbatim}

      \item \textit{firewire}:
      \begin{verbatim}
libraw1394-13-dev libdc1394-13-dev
      \end{verbatim}

      \item \textit{player}: para soportar el driver de player es necesario instalar player. Para ello, hay dos posibilidades:\\

Descargar e instalar los paquetes de este modo
      \begin{verbatim}
wget http://gsyc.es/~chuso/player_2.0.3-1_i386.deb
wget http://gsyc.es/~chuso/stage_2.0.3-1_i386.deb
sudo dpkg -i stage_2.0.3-1_i386.deb player_2.0.3-1_i386.deb
      \end{verbatim}
o seguir los pasos detallados en el \htlink{manual oficial}{http://playerstage.sourceforge.net/doc/ps_getting_started-1.6.txt} para la compilación e instalación manual.
      
\label{dri:mlayer} 
 	\item \textit{mplayer}: para soportar el driver de mplayer es necesario instalar mplayer y mendocer, así como los codecs necesarios para poder ver el vídeo que desees utilizar. Para ello instala los paquetes siguientes:\\
      \begin{verbatim}
mplayer mencoder
      \end{verbatim}
Para instalar todos los codecs hay dos posibilidades:\\
 http://www1.mplayerhq.hu/MPlayer/releases/codecs/

En esta página descargas un paquete con el nombre all-(ultima fecha).tar.bz2.
Descomprimes este paquete y copias todos los archivos que contiene en:
      \begin{verbatim}
		/usr/lib/win32/
      \end{verbatim}
Otra forma es instalar una herramienta como Automatix o easyUbuntu que ayuden a realizar esta tarea.

     \item \textit{recorder}: Este esquema también necesita mencoder. Ver apartado anterior (\textit{driver mplayer}).

     \item \textit{graphics\_gtk}: Los paquetes listados permiten compilar el driver y visualizar esquemas que lo utilicen
      \begin{verbatim}
libgtkglext1 libgtkglext1-dev glade glade-common libglade0 libglade2-0 libglade2-dev
      \end{verbatim}

     \item \textit{graphics\_xforms}: Los paquetes listados permiten compilar el driver y visualizar esquemas que lo utilicen
      \begin{verbatim}
libforms-bin libforms-dev libforms1 libformsgl1 libx11-dev
x11proto-core-dev libgl1-mesa libgl1-mesa-dev libglu1-mesa-dev
mesa-common-dev glutg3-dev libformsgl-dev
      \end{verbatim}
	
      \end{enumerate}
   \subsubsection{Compilación}
	En el directorio de descarga de \texttt{jdec} ejecuta
      \begin{verbatim}
make
      \end{verbatim}
	Ese mismo comando, en el directorio de cualquier esquema o driver, te servirá para compilarlo.

\subsection{Arranque de la plataforma y shell interno}
Para lanzar jdec, una vez completados los pasos de instalación y
configuración, se realiza ejecutando el archivo binario \textit{jde}.\\

Si se ejecuta con la opción \textit{--help}, la plataforma indica las
opciones de arranque:

\begin{verbatim}
$ jde --help
jdec 4.2-svn
Use: jde [config.file]

     [config.file] Sets an specific config file. Don't use this option to read default configuration.


\end{verbatim}

Una vez arrancada la aplicación, si se desea, se puede utilizar la
consola proporcionada en lugar del GUI, con las mismas posibilidades. Se puede
obtener un listado de opciones tecleando el comando \textit{help}.

\begin{verbatim}
jdec$ help
This is the shell of jdec 4.2-svn. Available commands:
  * quit
  * help
  * ls
      list the loaded schemas
  * ps
      print the non-slept schemas, their state and speed
      show the master GUI of jdec, to visually manage the schema set

  * [schemaname]
      run the schema
  * kill [schemaname]
      move the schema to slept state
  * guion [schemaname]
      show the GUI of the schema
  * guioff [schemaname]
      hide the GUI of the schema


\end{verbatim}

\subsubsection{Localización de plugins}
Para que todos los drivers y esquemas especificados en el fichero de configuración
puedan ser lanzados, han de ser accesibles para el enlazador dinámico. Ten una
copia del script \textit{ponpath} adecuado a tus necesidades en tu directorio de 
trabajo, donde puedas indicar las rutas de los plugins que necesitarás. Una vez
hecho, ejecuta siempre \texttt{source ponpath} o \texttt{. ponpath} en tu shell al menos una vez antes
de lanzar jde.\\
