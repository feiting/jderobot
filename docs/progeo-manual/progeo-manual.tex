% 0.5 Antonio Pineda 20070410
% 0.4 Manuel Mendoza 20072009
% 0.3 Victor Hidalgo 20071109
% 0.2 Antonio Pineda 20071009
% 0.1 Antonio Pineda 20073008

\documentclass[a4paper,12pt,notitlepage,openany]{article}
\usepackage{url}
%\usepackage[dvips]{graphicx}
%\usepackage{graphics}
\usepackage[spanish]{babel}
%\selectlanguage{spanish}
%\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage{babel}

%\usepackage{named}
\usepackage{geometry}
\usepackage{makeidx}
\usepackage{graphicx}
\usepackage{hthtml}

% Espaciado por defecto, (no afecta a figuras, minipages, pie de pagina...)
\usepackage{setspace}
%\setstretch{1.35}
%\setstretch{1.2}

%para subfiguras
\usepackage[normalsize]{subfigure}
\renewcommand{\subfigtopskip}{0pt}
\renewcommand{\subfigcapskip}{0pt}
\renewcommand{\subfigbottomskip}{0pt}

% Definimos el margen y el tipo de letra de los pies de figura
\usepackage[normal,bf]{caption2}
\setlength{\captionmargin}{20pt}
\renewcommand{\captionfont}{\footnotesize\slshape}
%\newcommand{\mycaption}[1]{\caption{\textit{\small{#1}}}} 

%Para que la bibliografia salga en el indice:
\let\OLDthebibliography=\thebibliography
\def\thebibliography#1{\OLDthebibliography{#1}%
  \addcontentsline{toc}{section}{\bibname}}

\geometry{left=3cm, right=3cm, top=3cm, bottom=3cm}
%\geometry{inner=2.5cm, outer=1.5cm, top=2cm, bottom=2cm}

\makeindex

\selectlanguage{spanish}
\bibliographystyle{plain}


%\pretolerance=10000
%Para que no corte las palabras al final de la linea.

\pagestyle{headings}

\author{José M. Cañas, A. Pineda, M. Mendoza, V. Hidalgo}
\title{Biblioteca de geometría proyectiva PROGEO}
\date{Universidad Rey Juan Carlos, \today}

\begin{document}
\maketitle

\begin{abstract}
Este manual explica cómo utilizar la biblioteca PROGEO para realizar cálculos de geometría proyectiva. Estos cálculos permiten procesar la información de puntos geométricos en el espacio 3D para obtener sus proyecciones en un plano imagen determinado. Mediante estas proyecciones, los puntos 3D pueden ser visualizados en un monitor, empleando para ello algún gestor gráfico. De igual forma, los cálculos pueden ser realizados a la inversa, de manera que a partir de varias proyecciones de un punto, podamos obtener las coordenadas 3D del mismo. Para los cálculos de \textit{proyección} y \textit{retroproyección} es indispensable contar con un punto de mira, que viene determinado mediante una cámara virtual o un par estereoscópico (dos cámaras alineadas en dos ejes y separadas por una distancia fija en el tercero). Cada uno de estos elementos de visualización dispone de un plano imagen sobre el que se podrán realizar proyecciones de puntos 3D, o utilizar las proyecciones en los mismos para las retroproyecciones.
\end{abstract}

%\pagenumbering{roman}
\setcounter{page}{1}
\setcounter{secnumdepth}{2}
\setcounter{tocdepth}{2}

\tableofcontents
%\listoffigures
%\listoftables

%-------------------------------------- INTRODUCCION --------------------------------------------------
\section{Introducción}
\subsection{Importancia de los gráficos en 3D}
En la actualidad, los gráficos 3D han revolucionado la manera de visualizar los resultados en las aplicaciones. Puesto que el mundo que nos rodea consta de tres dimensiones, con el tiempo se ha vuelto necesario representar la información visual con semejantes características a cómo el ser humano las percibe con la vista. Hasta hace poco tiempo esta tarea resultaba costosa computacionalmente debido a la escasa capacidad de cómputo de los ordenadores personales en cuanto a información gráfica se refiere. No obstante, en la actualidad, prácticamente cualquier computadora doméstica posee microprocesadores suficientemente potentes como para que esta labor se realice en tiempo real.\\

La facilidad para generar gráficos en tres dimensiones por ordenador han contribuído de manera notable al avance de muchas otras areas científicas, que antes veían mermadas sus posibilidades de simulación de sucesos al no disponer de la tecnología suficiente para probar los estudios realizados. De esta manera, hoy en día es posible practicar reproducciones geológicas disponiendo de un mapa en 3D de un terreno, estudiar en detalle la morfología de diferentes especies para avanzar en el estudio de la evolución, o incluso simular los posibles efectos y resultados de un transbordador espacial antes del lanzamiento real (Figura \ref{fig:representaciones-3D}).

\begin{figure}[htb]
\begin{center}
\includegraphics[width=15cm]{figs/simulacion-3d}
\end{center}
\caption{Representaciones en 3D}
\label{fig:representaciones-3D}
\end{figure}

Con este propósito, han aparecido en el mercado diversas herramientas de visualización (The Visualization ToolKit, ... [más herramientas] ...) así como varios motores de generación de gráficos, algunos de libre uso y distribución (OpenGL y Ogre) y otros de carácter privativo (DirectX). El motor gráfico de procesamiento de estos entornos aprovecha las capacidades de cálculo en tiempo real de la mayoría de las tarjetas gráficas existentes en el mercado, constituyendo de esta forma estándares de generación de gráficos que acompañan por defecto a los distintos sistemas operativos (DirectX en Microsoft Windows y OpenGL y Ogre en Linux y MacOS). Por todo ello, hoy resulta muy sencillo utilizar estos entornos para generar gráficos por ordenador y este hecho, junto con la reducción de precios en las tarjetas gráficas y aceleradoras, han permitido que cada vez más organismos de investigación dispongan de esta tecnología para sus diferentes estudios.\\

En este manual se describe y se resume el funcionamiento de parte de la tecnología sobre la que se fundamentan los motores gráficos que se han comentado antes. En el interior de estos entornos se utilizan implementaciones informáticas de técnicas matemáticas sobre geometría proyectiva. Esta rama de la geometría aporta las operaciones algebráicas matriciales subyacentes en la generación de gráficos 3D.\\

\subsection{Biblioteca PROGEO}
La biblioteca PROGEO se basa en las directrices de geometría proyectiva aplicadas por Richard Hartley y Andrew Zisserman \cite{hartley2004}. Utiliza el \textit{modelo de cámara Pinhole} (Figura \ref{fig:modelo-pinhole}) para las operaciones de proyección de puntos 3D. Aunque no es el único tipo, el modelo Pinhole es el modelo de cámara más común.

\begin{figure}[htb]
\begin{center}
\includegraphics[width=15cm]{figs/modelo-pinhole}
\end{center}
\caption{Modelo de cámara Pinhole}
\label{fig:modelo-pinhole}
\end{figure}

En este modelo se asume que cualquier punto $P(x,y,z)$ se proyecta en el plano de imagen através de otro único punto llamado \textit{Centro óptico}. La recta que une el punto P y el centro óptico se denomina \textit{Línea de proyección} e intersecta al plano imagen justo en el pixel $p('x','y')$, que es la proyección de $P(x,y,z)$. El centro óptico esta situado a la \textit{Distancia focal} del plano imagen. Este modelo lo completan el \textit{Eje óptico}, que es una línea perpendicular al plano imagen y que atraviesa al centro óptico, y también el \textit{Plano focal}, que es el plano perpendicular al eje óptico cuyos puntos no se proyectan en el plano imagen, incluyendo al centro óptico.\\

De esta manera, las operaciones matemáticas sobre puntos 3D se realizan siempre referidas a una cámara determinada, cuyas características están determinadas por el modelo ya comentado. También es posible realizar las transformaciones algebráicas en referencia a un par estéreo de cámaras (a su plano imagen). Dichas transformaciones son siempre referidas hacia puntos 3D, ya que de momento no se contempla el uso de lineas o curvas en el espacio.\\

Basandose en este modelo de cámara, PROGEO como biblioteca informática de programación define los tipos de datos y funciones apropiadas para poder realizar los cálculos geométricos que se necesiten. La biblioteca está programada en lenguaje C, permitiendo su integración en proyectos basados en este lenguaje o también en proyectos de lenguaje C++ (independientemente del sistema operativo y entorno de programación del proyecto).

%------------------------------------- ESTRUCTURA DE LA BIBLIOTECA ------------------------------------
\section{Estructura de la biblioteca}
Una vez introducida la biblioteca PROGEO, se detallan a continuación los tipos de datos y operaciones que proveé la biblioteca para los cálculos geométricos.

\subsection{Tipos de datos}
\subsubsection{HPoint2D}
El tipo de punto 2D de la biblioteca permite almacenar la información
de un punto en un plano (normalmente el plano imagen). La estructura
por tanto es la de dos coordenadas (x,y) y una tercera coordenada que
indica ... [no me acuerdo que indicaba h en el punto 2D]...\\

\begin{verbatim}
typedef struct {
  float x;
  float y;
  float h;
} HPoint2D;
\end{verbatim}

\subsubsection{HPoint3D}
El punto 3D en la biblioteca posibilita la representación conceptual de un punto en el espacio. La estructura está compuesta de tres coordenada \textit{(X,Y,Z)} y una tercera coordenada \textit{H} que indica el cuadrante en el que se encuentra el punto (delante, detrás o coincidente con el plano imagen).\\

\begin{verbatim}
typedef struct {
  float X;
  float Y;
  float Z;
  float H;
} HPoint3D;
\end{verbatim}

\subsubsection{TPinholeCamera}
\label{sec:tpinholecamera}
La estructura \textit{TPinholeCamera} representa un tipo de cámara de modelo Pinhole.\\

Toda cámara Pinhole se define por sus \textit{parámetros intrínsecos} y \textit{parámetros extrínsecos}.\\ Los extrínsecos se componen principalmente por dos puntos 3D (\textit{position} y \textit{foa}) y un ángulo expresado en radianes (\textit{roll}). El primer punto indica la posición de la cámara en el espacio, mientras que el segundo (foco de atención) permite trazar junto al primero un vector tridimensional y, de esta forma, indicar hacia donde está dirigida la observación de la cámara. Cada una de las coordenadas de estos puntos se expresan en milímetros. El tercer elemento es el ángulo que forma la cámara con respecto a un eje virtual que sería paralelo al vector definido por su posición y su foco de atención.\\

Adicionalmente, los parámetros intrínsecos de la cámara equivalen a \textit{fdist}, \textit{u0} y \textit{v0}. El primer parámetro es la distancia focal (distancia desde el foco de la cámara al plano imagen). El segundo y tercer parámetro indican la cantidad de píxeles en alto (u0) y ancho (v0) que ocupa un centímetro en el plano imagen de la cámara.\\

Por otro lado una cámara pinhole dispone de una matriz K (definida mediante los elementos \textit{k11..k34}) y una matriz de rotación y translación (definida mediante los parámetros \textit{rt11..rt44}), creadas a partir de sus parámetros intrínsecos e extrínsecos.\\

Los parámetros \textit{tr} y \textit{bl} equivalen a dos puntos 3D que especifican el punto más alto y a la derecha del plano imagen, y el punto más bajo y a la izquierda del mismo plano. Mediante estos dos puntos se puede construir un rectángulo que equivaldría al plano imagen de la cámara en el espacio.\\

Por último, un tipo cámara Pinhole posee un nombre (\textit{name}) que la permite diferenciarse de otras cámaras utilizadas en el mismo entorno.\\

\begin{verbatim}
typedef struct {
  HPoint3D position;
  HPoint3D foa;
  float roll;
  float fdist;
  float u0,v0;
 
  float k11,k12,k13,k14,k21,k22,k23,k24,k31,k32,k33,k34;
 
  float rt11,rt12,rt13,rt14,rt21,rt22,rt23,rt24,rt31,rt32,
        rt33,rt34,rt41,rt42,rt43,rt44;

  HPoint3D tr, bl;

  char name[256];
} TPinHoleCamera;
\end{verbatim}

\subsubsection{TPinholeStereoCamera}
\
El tipo de datos \textit{TPinholeStereoCamera} representa un tipo de
cámara estéreo basada en el modelo de cámara Pinhole. Este tipo de
cámara se caracteriza por estar compuesta de dos cámaras sencillas
(\textit{TPinholeCamera camera1} y \textit{camera2}) separada entre sí
por una distancia fija \textit{baseline}. Toda cámara de este tipo se compone (al igual que una cámara sencilla) de una posición 3D (\textit{position}) y un segundo punto 3D (\textit{foa}) que permite crear un vector con el primero que indique la dirección de observación de la cámara, además del ángulo que forma con respecto al vector de esa dirección (\textit{roll}).\\

Por otra parte, existe la posibilidad de diferenciar distintas cámaras de este tipo mediante el elemento \textit{name}, que permite asignar un nombre a la cámara para distinguirla del resto.\\

\begin{verbatim}
typedef struct {
 HPoint3D position;
 HPoint3D foa;
 float roll;

 TPinHoleCamera camera1;
 TPinHoleCamera camera2;
 float baseline;

 char name[256];	
} TPinHoleStereocamera;
\end{verbatim}

\subsection{Funciones}
\subsubsection{Update Camera Matrix}
Esta función se encarga de actualizar la matriz K y la matriz de
rotación y translación para una determinada cámara simple con los
nuevos valores de la misma dependiendo de sus parámetros intrínsecos e extrínsecos.\\

La operación debe invocarse tras efectuar un cambio en algún parámetro de la cámara tal como: modificar su distancia focal, mover la cámara a otra posición o modificar su foco de atención, determinar un giro de la cámara sobre si misma mediante el elemento \textit{roll}, etc.\\

Su cabecera de invocación es la siguiente:

\begin{verbatim}
extern void update_camera_matrix(TPinHoleCamera *camera);
\end{verbatim}

\subsubsection{Update StereoCamera Matrix}
Al igual que la anterior, esta función calcula las matrices K y de
rotación y translación para las dos cámaras que componen un par
estereoscópico. Estas se calculan a partir de los parámetros
intrínsecos e extrínsecos de cada cámara y de la separación entre ambas.\\

De nuevo, la operación se debe invocar tras efectuar un cambio en alguno de estos parámetros.\\

Su cabecera de invocación es la siguiente:

\begin{verbatim}
extern void update_stereocamera_matrix(TPinHoleStereocamera *stereo);
\end{verbatim}

\subsubsection{Project}
La función de proyección permite proyectar un punto 3D sobre el plano imagen de una cámara, para obtener el punto 2D contenido en el mismo. Esta función permite visualizar un punto 3D sobre el plano imagen de una cámara, y de esta forma dibujarlo sobre un monitor plano.\\

La cabecera de la función recibe un punto 3D y una cámara como entradas y devuelve un punto 2D como salida:

\begin{verbatim}
int project(HPoint3D in, HPoint2D *out, TPinHoleCamera camera);
\end{verbatim}

Un ejemplo práctico de esta función se puede encontrar en el apartado \ref{sec:project}.

\subsubsection{Backproject}
La función de retroproyección efectúa la operación inversa a la anterior. Mediante esta función se puede obtener las coordenadas 3D de un punto proyectado en varios planos imagen de diferentes cámaras. Para ello, dado un punto 2D contenido en el plano imagen de una cámara concreta, permite obtener la representación 3D de ese punto. Esa representación, junto con el foco de la cámara desde la que se observe, permite trazar un segmento en el espacio que contiene al punto 3D buscado.\\

De esta forma, si se realiza la misma operación para el mismo punto pero desde otro cámara (con otra proyección 2D distinta), es posible hayar un nuevo vector director, que o bien corta o se cruza con el anterior. El punto de cruce en el espacio es precisamente el punto 3D buscado.\\

La cabecera de la función, por tanto, recibe un punto 2D y la cámara concreta del plano imagen como entradas, y devuelve un punto 3D (la representación 3D del punto 2D de entrada):

\begin{verbatim}
int backproject(HPoint3D *out, HPoint2D in, TPinHoleCamera camera);
\end{verbatim}

Un ejemplo práctico de esta función se puede encontrar en el apartado \ref{sec:backproject}.

\subsubsection{DisplayLine}
La función permite saber si una determinada línea formada por dos puntos 2D se puede visualizar dentro de un plano imagen de un tamaño concreto (normalmente 320x240 píxeles).\\

Para ello determina si dicho segmento se encuentra por delante o por detrás del plano imagen, y en caso de encontrarse delante, determina los puntos 2D correctos para poder ser dibujados sobre el plano, siempre y cuando este segmento se encuentre dentro del área visible por dicho plano. En tal caso, se devuelven dichos puntos para poder ser mostrados en un monitor.\\

La cabecera de la función, por tanto, consiste en dos puntos 2D de entrada (los que determinan el segmento) y dos puntos 2D de salida (los puntos correctos para ser visualizados):

\begin{verbatim}
int displayline(HPoint2D p1, HPoint2D p2, HPoint2D *a, HPoint2D *b);
\end{verbatim}

Un ejemplo práctico de esta función se puede encontrar en el apartado \ref{sec:project}.

\subsubsection{Display Camera Info}
Esta función sirve exclusivamente para mostrar en consola la información de una cámara concreta. Para ello, imprime por salida estándar la información completa de una cámara (con todos sus parámetros).\\

Su cabecera es la siguiente:

\begin{verbatim}
void display_camerainfo(TPinHoleCamera camera);
\end{verbatim}

\subsection{Definiciones}
\subsubsection{Parámetros intrínsecos de la cámara Apple iSight}
Estas definiciones equivalen a los parámetros intrínsecos basados en el modelo Pinhole determinados para una cámara Apple iSight.

\begin{verbatim}
#define ISIGHT_PINHOLE_FDIST 405.4
#define ISIGHT_PINHOLE_U0 142.6
#define ISIGHT_PINHOLE_V0 150.4
\end{verbatim}

\subsubsection{Cálculo de distancias}
Los siguientes macros permiten calcular las distancias euclídeas para puntos 2D y puntos 3D dentro de la biblioteca PROGEO.

\begin{verbatim}
#define DIST2D(p1,p2) sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y))
#define DIST3D(p1,p2) sqrt((p1.X-p2.X)*(p1.X-p2.X)+(p1.Y-p2.Y)*(p1.Y-p2.Y)
                           +(p1.Z-p2.Z)*(p1.Z-p2.Z))
\end{verbatim}

%------------------------------------- USO DE LA BIBLIOTECA -------------------------------------------
\section{Ejemplos de uso de la biblioteca}
En esta sección del manual se muestran algunos ejemplos de las
funciones más comunes que se utilizan en PROGEO. Estos ejemplos
enseñan algunos ejemplos prácticos de dichos procedimientos aplicados
principalmente a visualización de gráficos en 3D.\\

Estas funciones son las de proyección y retroproyección de puntos.

\subsection{Ejemplo de proyección}
\label{sec:project}
En este código se utiliza la función de proyección para proyectar un
conjunto de líneas formadas por puntos en 3D que conforman el plano de
una habitación.\\

En dicha habitación existen dos cámaras que visualizan diferentes
perspectivas de la misma. Mediante esta función podemos, en
todo momento, dibujar las proyecciones 2D de estas líneas en el plano
imagen de cada cámara.

\begin{verbatim}

...

/* Suponemos que las siguientes cámaras tienen los parámetros definidos.*/
TPinholeCamera camera1,camera2;

/* Suponemos que tenemos una lista de puntos, donde los puntos pares
   equivalen a puntos inicio de línea y los impares son finales de línea.*/
HPoint3D lineList[MAX_LINES*2];

/* Disponemos de dos buffers de memoria que se visualizarán en
pantalla y que se inicializarán pintados de  color blanco.*/
unsigned char buffer1[MAX_HEIGHT*MAX_WIDTH*COLOR_DEPTH];
unsigned char buffer2[MAX_HEIGHT*MAX_WIDTH*COLOR_DEPTH];

setWhiteBuffer(&buffer1);
setWhiteBuffer(&buffer2);


...

/* Declaramos los puntos 2D necesarios para el dibujado.*/
HPoint2D auxPoint1,auxPoint2;
HPoint2D goodAuxPoint1,goodAuxPoint2;

/* Obtenemos las proyecciones de cada punto y dibujamos en el buffer. */
for(int i=0;i<MAX_LINES;i++)
{

     /* PROYECCIONES DE LAS LINEAS 3D EN LA CAMARA 1.*/

     project(lineList[i],&auxPoint1,camera1);
     project(lineList[i+1],&auxPoint2,camera1);

     /* Obtengo los puntos 2D correctos tras comprobar que se
        encuentran dentro del plano imagen y que se pueden visualizar
        en el mismo .*/
     if(displayline(auxPoint1,auxPoint2,&goodAuxPoint1,&goodAuxPoint2))
     {

          /* Dibujo en el buffer de la camara 1 en color negro si se
             visualiza correctamente en el plano imagen.*/

          lineinimage(goodAuxPoint1,goodAuxPoint2,FL_BLACK,&buffer1);
     }

     /* PROYECCIONES DE LAS LINEAS 3D EN LA CAMARA 2.*/

     project(lineList[i],&auxPoint1,camera2);
     project(lineList[i+1],&auxPoint2,camera2);

     if(displayline(auxPoint1,auxPoint2,&goodAuxPoint1,&goodAuxPoint2))
     {
          lineinimage(goodAuxPoint1,goodAuxPoint2,FL_BLACK,&buffer2);
     }

}/* Fin del bucle for.*/

...

/* FIN DE CODIGO */
\end{verbatim}

\begin{figure}[htb]
\begin{center}
\includegraphics[width=10cm]{figs/project-example}
\end{center}
\caption{Ejemplo de proyección}
\label{fig:project-example}
\end{figure}

El resultado, si de dibujara con algún gestor gráfico, sería el que
muestra la figura \ref{fig:project-example}, donde se aprecian las dos
perspectivas captadas por las cámaras enfocando al suelo de la habitación.

\subsection{Ejemplo de retroproyección}
\label{sec:backproject}
En el siguiente ejemplo veremos una muestra de triangulación para
obtener las coordenadas 3D de un punto en el espacio, que se proyecta
en el plano imagen de dos cámaras distintas.\\

En primer lugar se hayará la recta que une el foco de la cámara 1 con
el punto 3D donde se situa la proyección del punto en el espacio. Se
realizará de la misma forma para la cámara 2.\\

Una vez definidas las dos rectas, hayaremos el cruce o intersección de
las mismas en el espacio dando como resultado el punto 3D buscado.\\

\begin{verbatim}

...

/* Suponemos que las siguientes cámaras tienen los parámetros definidos.*/
TPinholeCamera camera1,camera2;

/* Translación de coordenadas Graficas a Opticas y viceversa. */
#define GRAPHIC_TO_OPTICAL_X(x,y) (SIFNTSC_ROWS-1-y)
#define GRAPHIC_TO_OPTICAL_Y(x,y) (x)
#define OPTICAL_TO_GRAPHIC_X(x,y) (y)
#define OPTICAL_TO_GRAPHIC_Y(x,y) (SIFNTSC_ROWS-1-x)

/* Suponemos que disponemos de la posición en píxeles del punto 3D.*/
int pointxCam1,pointyCam1;
int pointxCam2,pointyCam2;

...

/* Primeramente definimos puntos auxiliares.*/
HPoint2D auxPoint2DCam1,auxPoint2DCam2;
HPoint3D auxPoint3DCam1,auxPoint3DCam2;

/* Obtenemos los puntos 2D a partir de las coordenadas opticas.*/
auxPoint2DCam1.x = GRAPHIC_TO_OPTICAL_X(pointxCam1,pointyCam1);
auxPoint2DCam1.y = GRAPHIC_TO_OPTICAL_Y(pointxCam1,pointyCam1);
auxPoint2DCam1.h = 0;

auxPoint2DCam2.x = GRAPHIC_TO_OPTICAL_X(pointxCam2,pointyCam2);
auxPoint2DCam2.y = GRAPHIC_TO_OPTICAL_Y(pointxCam2,pointyCam2);
auxPoint2DCam2.h = 0;

/* Obtenemos los puntos 3D donde se encuentran los puntos 2D.*/
backproject(&auxPoint3DCam1,auxPoint2DCam1,camera1);
backproject(&auxPoint3DCam2,auxPoint2DCam2,camera2);

/* Ahora con los dos puntos 3D obtenidos y la posición de los focos
   de cada cámara podemos calcular dos rectas en el espacio.*/


...


\end{verbatim}

%------------------------------------- INTEGRACION DE CAMARAS DE OTRAS PLATAFORMAS -------------------
\section{Integración de cámaras procedentes de otras plataformas}
\subsection{Importando cámaras de Gazebo}
En este apartado vamos a ver como importar las imágenes sintéticas
generadas por la cámara simulada de gazebo a progeo. La idea es
entender la relación entre el modelo de cámara opengl (que es el que
usa gazebo), con el modelo de cámara progeo (que es el que usa jde).
\\\\
La gran diferencia entre estos dos modelos, se encuentra en como
define cada uno los parametros intrínsecos, opengl (Gazebo)
maneja relación de aspecto y progeo maneja focal y centro óptico. Por
otro lado los parametros extrínsecos, son iguales para ambos modelos
(foco de atención y un roll).
\\\\
Pero vayamos por partes, primero vamos a ver el modelo de cámara de
gazebo. Gazebo usa la proyección perspectiva de Opengl estándar
(modelo pinhole). La relación de aspecto para cada cámara
esta definida por cuatro atributos:

\begin{itemize}
\item{El ángulo de vista horizontol (fovy)}
\item{El ratio de aspecto (ancho/altura)}
\item{Las distancias nearClip y farClip. Con la distancia nearClip, haremos que
    la cámara que no vea objetos que están a un distancia menor que
    ésta, Y con la distancia farClip haremos que la cámara no vea
    objetos que están a una distancia mayor que ésta}
\end{itemize}

Estos cuatro parámetros, lo podemos ver en la figura \ref{fig:gazebo}
gráficamente para poder entenderlos mejor.

\begin{figure}[htb]
\begin{center}
\includegraphics[width=10cm]{figs/gazebo-camara}
\end{center}
\caption{Modelo de cámara de Gazebo}
\label{fig:gazebo}
\end{figure}

Una vez visto el modelo de cámara Gazebo, vamos a pasar a ver como
importar este modelo a PROGEO. Antes hemos hablado de que los parámetros
intrínsecos de progeo se basan en la distancia focal y el centro
óptico. Al estar trabajando con una cámara simulada, esta tendrá una
calibración ideal por lo que el centro óptico será (120,160). Sin embargo, obtener la
focal no es tan fácil. Dicha focal la calculamos a partir de la
fórmula \ref{equ:formula}, que es la que relaciona PROGEO con Gazebo.

\begin{equation}
  \Phi = 2  \arctan{\frac{altura}{2f}}\label{equ:formula}
\end{equation}

Despejando de la fórmula anterior, obtenemos la fórmula para calcular
la focal.

\begin{equation}
  f = \frac{altura}{2 \tan{\frac{\Phi}{2}}}
\end{equation}

Siendo: f la distancia focal, altura el número de pixeles de la imagen
a lo alto y $\Phi$ el ángulo de apertura.

\subsection{Importando cámaras de ARToolKit}
\textit{ARToolKit} \footnote{\label{1}http://www.hitl.washington.edu/artoolkit/download/} es una herramienta de calibración desarrollada en conjunto por las universidades de Osaka, Washington y Canterbury. Mediante una serie de patrones diferentes nos ayuda a obtener los parametros intrínsecos y extrínsecos de la cámara. Con los programas de calibración (\textit{calib\_dist} y \textit{calib\_cparam}) obtenemos el centro de la imagen, la distorsión por el tamañoo de los píxeles y la distancia focal. Con \textit{exview} obtenemos los parametros extrínsecos, un vector 3D con la posición de la cámara y un \textit{quaternion} que nos indica hacia dónde mira la cámara y el roll con el que lo hace.\\

La estructura del tipo cámara en la biblioteca PROGEO puede consultarse en el apartado \ref{sec:tpinholecamera}.\\

Esta estructura la rellenamos con los datos que nos da \textit{ARToolKit}. Con los programas de calibración obtendremos la distancia focal (\textit{fdist}) y el centro de la imagen (\textit{u0,v0}), y los demás datos que forman parte de la matriz K (\textit{k11,k12,k13,k14,k21,k22...}):

\[
K = \left( \begin{array}{lcr}
            f_h     & s   		& u_0  \\
            0     	& f_v   	& v_0  \\
            0				& 0				& 1
           \end{array}
    \right)
\]

\begin{figure}[htb]
\begin{center}
\includegraphics{figs/exview2}
\end{center}
\caption{Ejecución normal de \textit{exview}}
\end{figure}

Con \textit{exview} obtendremos la posicion de la cámara (\textit{position}) y el resto de parámetros de la matriz de rotación+traslación(\textit{rt11,rt12,rt13,rt14,rt21,rt22...}) los obtendremos a partir del quaternión mediante las siguientes ecuaciones:

\[
RT = \left( \begin{array}{l}
							\underline{R \quad | -RC} \\
							0 \quad 0 \quad 0 \quad 1
							\end{array}
			\right)
\]

$ rt_{11}= q_w^2 + q_x^2 - q_y^2 - q_z^2 $\\
$ rt_{12}= 2 * (q_x*q_y - q_w*q_z)$\\
$ rt_{13}= 2 * (q_w*q_y + q_x*q_z)$\\
$ rt_{14}= -x * rt_{11} - y * rt_{12} - z * rt_{13}$\\
$ rt_{21}= 2 * (q_x*q_y + q_w*q_z)$\\
$ rt_{22}= q_w^2 - q_x^2 + q_y^2 - q_z^2$\\
$ rt_{23}= 2 * (q_y*q_z - q_w*q_x)$\\
$ rt_{24}= -x * rt_{21} - y * rt_{22} - z * rt_{23}$\\
$ rt_{31}= 2 * (q_x*q_z - q_w*q_y)$\\
$ rt_{32}= 2 * (q_w*q_x + q_y*q_z)$\\
$ rt_{33}= q_w^2 - q_x^2 - q_y^2 + q_z^2$\\
$ rt_{34}= -x * rt_{31} - y * rt_{32} - z * rt_{33}$\\
$ rt_{41}= 0$\\
$ rt_{42}= 0$\\
$ rt_{43}= 0$\\
$ rt_{44}= 1$\\


Sólo resta una observación, y es que en \textit{ARToolKit} se trabaja con imágenes en un tamaño de 640x480 por lo que, si se trabaja con imágenes en 320x240, tendremos que dividir por la mitad tanto el centro de la imagen como la distancia focal.

%------------------------------------------------------------------------------------

\nocite{*}
%\bibliographystyle{alpha}
\bibliography{progeo-manual}
\end{document}
