\documentclass[oneside,a4paper,12pt]{article}
\usepackage[latin1]{inputenc}
\usepackage[spanish,activeacute]{babel}
\usepackage{geometry}
\usepackage{url}
\usepackage{graphicx}
\usepackage{a4wide}
\usepackage[normalsize]{subfigure}
\usepackage{titlesec}
\usepackage{listings}

\geometry{a4paper, left=3.5cm, right=2cm, top=3cm, bottom=2.0cm, headsep=1.5cm}

\RequirePackage{color}
% Definiendo colores para los listados de código fuente
\definecolor{violet}{rgb}{0.5,0,0.5}
\definecolor{navy}{rgb}{0,0,0.5}

\definecolor{hellgelb}{rgb}{1,1,0.87}
\definecolor{colKeys}{rgb}{0.5,0,0}
\definecolor{colIdentifier}{rgb}{0,0,0}
\definecolor{colComments}{rgb}{0.5,0.5,0.5}
\definecolor{colString}{rgb}{0.86,0,0}


\lstset{
        float=hbp,
        basicstyle=\ttfamily\small,
        identifierstyle=\color{colIdentifier},
        keywordstyle=\color{colKeys} \bfseries,
        stringstyle=\color{colString},
        commentstyle=\color{colComments},
        columns=flexible,
        tabsize=4,
        frame=single,
        extendedchars=true,
        showspaces=false,
        showstringspaces=false,
        numbers=none, %left para poner números de línea a la izquierda
        numberstyle=\tiny,
        breaklines=false,
        backgroundcolor=\color{hellgelb},
        breakautoindent=true,
        captionpos=b
}


\begin{document}

\thispagestyle{empty}
\baselineskip 1.35\baselineskip
\vspace{2cm}
\begin{figure}[htb]
   \centerline{\resizebox{.50\textwidth}{!}{\includegraphics{figs/logo_urjc}}}
   \vspace{2cm}
   \centerline{\resizebox{.50\textwidth}{!}{\includegraphics{figs/logo}}}
\end{figure}

\begin{center}
  {\Large {\bf HOWTO DE IPP }}
  \vspace{2cm}
\\Jos\'e Antonio Santos Cadenas
\end{center}
\newpage


\section{Introducci\'on}

La biblioteca IPP (Integrated Performance Primitives) de Intel es una biblioteca que permite mejorar el rendimiento de nuestras aplicaciones, ya que implementa funciones que realizan sus operaciones utilizando instrucciones del procesador más eficientes.

En concreto ofrece funciones con alto rendimiento para:
\begin{itemize}
\item Trabajo con imágenes
\item Trabajo con matrices
\item Procesamiento de señales
\item Criptografía
\end{itemize}

Para más información a cerca de las ventajas de ipp se puede consultar su documentación en el directorio \textit{doc} de la distribución instalada. En él encontraremos un nutrido manual en el que se explican detalladamente todas las funciones implementadas en la biblioteca. Así como algunas pinceladas generales y tutoriales de uso para familiarizarnos con la biblioteca.\

Este manual no tiene como objetivo sustituir al manual oficial de la biblioteca, sino mostar algunas de las utilidades y facilitar el primer acercamiento a la misma.


\section{Instalaci\'on}

Para instalar IPP hay que descargar en primer lugar el paquete de instalación de la página web de intel\footnote{http://www.intel.com/cd/software/products/asmo-na/eng/perflib/ipp/302910.htm}.

Para ello se elige el tipo de licencia que se desea. En mi caso elegí la licencia gratuita y no comercial para GNU/Linux y acepté los términos. Una vez aceptada la licencia, hay que seleccionar el producto a descargar, en este caso seleccionamos ``Intel® Integrated Performance Primitives (Intel® IPP) for Linux''. En este apartado nos pedirá una dirección de  email para registrarnos, a esta dirección nos enviará el número de licencia que tendremos que utilizar durante el período de instalación. \\

Una vez registrados nos aparecerá una página como la de la figura \ref{fig:descarga}. Elegimos el paquete que nos convenga, para 32 o 64 bits (según la tecnología que se emplee). En mi caso seleccioné el paquete para IA-32 (marcado en la figura). Seleccionamos y comenzará la descarga.\\

\begin{figure}
	\begin{center}
		\includegraphics[scale=0.6]{figs/web1.png}
	\end{center}
	\caption{Selección de los paquetes de descarga.}
	\label{fig:descarga}
\end{figure}

Cuando finalice la descarga se extrae el contenido del archivo comprimido (tgz). Se nos creará un directorio llamado \textit{l\_ipp\_ia32\_p\_5.2.XXX}, dentro del cual existe un archivo de instalación llamado \textit{install.sh}. Le otorgaremos permisos de ejecución en caso de no tenerlos y lo ejecutamos.\\

Nos irán apareciendo ventanas más o menos como las que siguen:\\

\begin{tabular}{|p{14cm}|}
		\hline
	\begin{scriptsize}
	\begin{verbatim}
Please make your selection by entering an option:

      1. Install as a root.
      2. Install as sudo to root.
      3. Install as current user.
      h. Help.
      x. Exit.

Please type a selection:
	\end{verbatim}
	\end{scriptsize}
	\\
	\hline
\end{tabular}\\

En este caso si se está utilizando ubuntu y se tienen los permisos adecuado (se es usuario con permisos para hacer sudo) lo mejor es seleccionar la opción 2. Nos pide la contraseña y continúa.\\

En este caso nos preguntará por la acción que deseamos realizar, elegimos la opción 1 (install) y nos preguntará por la forma de aportar la licencia.

\begin{tabular}{|p{14cm}|}
		\hline
	\begin{scriptsize}
	\begin{verbatim}
===============================================================================
Welcome to the Intel(R) Integrated Performance Primitives v5.2 for Linux* on IA-32 Intel(R) Architecture Installation

Please make your selection by entering an option from the choices below:

        1. Install
        2. Readme
        3. Release Notes
        4. Installation Guide
        h. Help
        x. Exit

Please type a selection:   1

===============================================================================
Provide a Serial Number or License File

Please make your selection by entering an option from the choices below:

        1. Provide your serial number [Recommended]
             Use this option  if  you  have  a  serial number  to  install  and
             register  your  software.  The Intel(R) Software Setup  Assistant
             may connect to the Intel(R) Software Development Products Registration Center
             to verify your serial number. Please refer to the Intel(R) Privacy Policy
             regarding the collection and handling of your personal information.
             Your Serial Number is in XXXX-XXXXXXXX format.
        2. Provide the absolute path for an existing license file.
             Use this option if you have obtained a license file instead of a
             serial number.
        3. Where do I find my Serial Number?
        4. Intel(R) Privacy Policy
        b. Go Back.
        h. Help.
        x. Exit.

Please type a selection or Serial Number:
	\end{verbatim}
	\end{scriptsize}
	\\
	\hline
\end{tabular}\\

Si tenemos acceso a internet elegiremos la opción 1 en otro caso seleccionaremos la opción 2 para poder introducir la licencia mediante el archivo que nos han enviado por correo electrónico (.lic).

Eligiendo la opción 1 introducimos el número de licencia y continuamos.\\

\begin{tabular}{|p{14cm}|}
		\hline
	\begin{scriptsize}
	\begin{verbatim}
Enter Serial Number:   XXXX-XXXXXXXX

The  Intel(R) Software  Setup Assistant  may  attempt to  connect  to  the
Intel(R) Software Development Products Registration Center to validate your Serial Number.
 This may take several minutes depending on your network.  Please wait...

You may press Ctrl+C to cancel.
Extracting...           ###############################################################[100%]

Would you like to install the following?
    Intel(R) IPP 5.2 for Linux* on IA-32 Intel(R) Architecture
<Enter> to continue, or x to exit: 
--------------------------------------------------------------------------------
Please read the following license agreement carefully.  Prior to installing the
software, you will be asked to agree to the terms and conditions of the
following license agreement.
--------------------------------------------------------------------------------
Please press Enter to continue.
	\end{verbatim}
	\end{scriptsize}
	\\
	\hline
\end{tabular}\\

En este momento aparece la licencia y al final de la misma nos pregunta:\\

\begin{tabular}{|p{14cm}|}
		\hline
	\begin{scriptsize}
	\begin{verbatim}
Enter 'accept' to continue, 'reject' to exit
	\end{verbatim}
	\end{scriptsize}
	\\
	\hline
\end{tabular}\\

Tecleamos \textit{accept} y pulsamos \textit{enter}. Posteriormente nos pregunta por la ruta en la que deseamos instalar, en mi caso he dejado la que viene por defecto, así que simplemente acepto pulsando \textit{enter}. En otro caso se especificará la ruta y se aceptará del mismo modo.

Esperamos un rato y nos informará de que ya está instalado. Pulsamos \textit{enter} para que borre los archivos temporales y una vez más para salir del programa de instalación.

\section{Utilizaci\'on en programas}

Para poder utilizar la biblioteca hay que incluir su archivo de cabecera en nuestro código con:\\

\begin{tabular}{|p{14cm}|}
		\hline
	\begin{scriptsize}
	\begin{verbatim}
#include<ipp.h>
	\end{verbatim}
	\end{scriptsize}
	\\
	\hline
\end{tabular}\\

Posteriormente a la hora de compilar hay que añadir unos flags para que se encuentre ese archivo de cabecera y las bibliotecas dinámicas correspondientes.

Con este flag se consigue que se busque el archivo de cabecera en la ruta apropiada.\\

\begin{tabular}{|p{14cm}|}
		\hline
	\begin{scriptsize}
	\begin{verbatim}
-I/opt/intel/ipp/5.2/ia32/include
	\end{verbatim}
	\end{scriptsize}
	\\
	\hline
\end{tabular}\\

Y estos ayudan a que se encuentren y enlacen en tiempo de ejecución las bibliotecas dinámicas que implementan el código.\\

\begin{tabular}{|p{14cm}|}
		\hline
	\begin{scriptsize}
	\begin{verbatim}
-L/opt/intel/ipp/5.2/ia32/lib -L/opt/intel/ipp/5.2/ia32/sharedlib

-lippaca6 -lippacpx -lippac -lippact7 -lippacv8 -lippacw7 -lippcca6
-lippccpx -lippcc -lippcct7 -lippccv8 -lippccw7 -lippcha6 -lippchpx 
-lippch -lippcht7 -lippchv8 -lippchw7 -lippcore -lippcva6 -lippcvpx 
-lippcv -lippcvt7 -lippcvv8 -lippcvw7 -lippdca6 -lippdcpx -lippdc 
-lippdct7 -lippdcv8 -lippdcw7 -lippia6 -lippipx -lippi -lippit7
-lippiv8 -lippiw7 -lippja6 -lippjpx -lippj -lippjt7 -lippjv8 -lippjw7 
-lippma6 -lippmpx -lippm -lippmt7 -lippmv8 -lippmw7 -lippsa6 
-lippsca6 -lippscpx -lippsc -lippsct7 -lippscv8 -lippscw7 -lippspx 
-lippsra6 -lippsrpx -lippsr -lippsrt7 -lippsrv8 -lippsrw7 -lipps 
-lippst7 -lippsv8 -lippsw7 -lippvca6 -lippvcpx -lippvc -lippvct7 
-lippvcv8 -lippvcw7 -lippvma6 -lippvmpx -lippvm -lippvmt7 
-lippvmv8 -lippvmw7
	\end{verbatim}
	\end{scriptsize}
	\\
	\hline
\end{tabular}\\

\section{Funciones \'utiles}

A continuación se describen algunas de las utilidades que ofrece ipp para el tratamiento de imágenes\footnote{Todo el código que se muestra a continuación no hace control de errores. Las funciones devuelven códigos de error que se están ignorando, si se quieren controlar posibles fallos es recomendable que se evalúe ese valor devuelto por cada función.}.

\subsection{Cómo transformar imágenes}
Las transformaciones sencillas de imágnes generalmente requieren el uso de bucles, que son computacionamente costosos. Ipp ofrece algunas funciones que permiten realizar estas transformaciones de manera más eficaz, permitiendo ahorrar cómputo en estas conversiones y utilizarlo en ejecutar otros algoritmos más complejos.

Algunos ejemplos:

\begin{itemize}

  \item Convertir una imagen a escala de grises

   \begin{lstlisting}[language=C]

   IppiSize imgtam;

   imgtam.height=alto;
   imgtam.width=ancho;

   ippiRGBToGray_8u_C3C1R ((Ipp8u *)img_origen_color, tam_fila*3,
                             (Ipp8u *)img_destino_bn, tam_fila, imgtam);

   \end{lstlisting}

  \item Multiplicar dos imágenes píxel a píxel

   \begin{lstlisting}[language=C]

   IppiSize imgtam;

   imgtam.height=alto;
   imgtam.width=ancho;
   
   ippiMulScale_8u_C3R((Ipp8u *)img_origen, tam_fila_origen1,
                        (Ipp8u *)img_origen_2, tam_fila_origen2,
                        (Ipp8u *)img_destino, tam_fila_destino, imgtam);
   \end{lstlisting}

   \item Invertir una imagen como si se reflejase en un espejo

   \begin{lstlisting}[language=C]

   IppiSize imgtam;

   imgtam.height=alto;
   imgtam.width=ancho;

   ippiMirror_8u_C4R ((Ipp8u *)img_origen, ancho*4, (Ipp8u *)img_destino,
                      ancho*4, imgtam, ippAxsVertical);

   \end{lstlisting}
   
\end{itemize}



\subsection{Cómo copiar imágenes}

 Para copiar imágenes se puede utilizar la siguiente función:
 
   \begin{lstlisting}[language=C]
   
   IppiSize imgtam;

   imgtam.height=alto;
   imgtam.width=ancho;
   
   ippiCopy_8u_C3R((Ipp8u *)img_origen, tam_fila,
                    (Ipp8u *)img_destino, tam_fila, imgtam)

   \end{lstlisting}

   También se puede copiar de una imagen con 3 bytes por píxel a una con 4 bytes por píxel.

   \begin{lstlisting}[language=C]

   IppiSize imgtam;

   imgtam.height=alto;
   imgtam.width=ancho;
   
   ippiCopy_8u_C3AC4R ((Ipp8u *)img_origen, tam_fila*3,
                        (Ipp8u*)img_destino, tam_fila*4, imgtam);

   \end{lstlisting}

\subsection{Cómo calcular flujo óptico}
El cálculo del flujo óptico es una operación compleja y costosa computacionalmente. El método propuesto en este apartado es el algoritmo de Lukas-Kanade. A pesar de que existe una función que realiza el cálculo mediante este método, es necesario transformar las imágenes de entrada para que coincidan con el tipo de entrada de la función, así como buscar los puntos relevantes sobre los que calcular el flujo.\

El primer paso es encontrar los puntos relevantes, para ello se requiere inicializar una estructura temporal para poder realizar el cálculo y otra para guardar los autovalores de todos los puntos.\

   \begin{lstlisting}[language=C]

   IppiSize imgtam;
   int eigen_buff_tam;
   int int eig_val_s;
   Ipp8u *eig_buffer;
   Ipp32f *eig_val;

   imgtam.height=alto;
   imgtam.width=ancho;

   ippiMinEigenValGetBufferSize_8u32f_C1R(imgtam, 3, 3, &eigen_buff_tam);

   //Estructura temporal para el cálculo de los autovalores
   eig_buffer=(Ipp8u*)malloc(sizeof (Ipp8u)*eigen_buff_tam);

   //Estructura para almacenar los autovalores
   eig_val=ippiMalloc_32f_C1 (ancho, alto, &eig_val_s);

   \end{lstlisting}

Una vez creadas las estructuras necesarias, se procede a calcular los autovalores de la matriz que rodea a cada punto\footnote{Consultar el manual para conocer más detalles sobre cómo se calculan los autovalores}, en concreto el menor de ellos.\

   \begin{lstlisting}[language=C]

   ippiMinEigenVal_8u32f_C1R((Ipp8u*)img_bn, ancho,
                          eig_val, ancho*sizeof(Ipp32f),
                          imgtam, ippKernelScharr, 3, 3, eig_buffer);

   \end{lstlisting}

Después se toman los puntos cuyos valores sean más grandes, y se incluyen en una lista como la que sigue:\

   \begin{lstlisting}[language=C]

   IppiPoint_32f prev[n_puntos_de_interes];
 
   prev[i].x=coordenada_x_del_punto;
   prev[i].y=coordenada_y_del_punto;

   \end{lstlisting}

Esta lista será la que se pase a la función que calcule el flujo óptico para indicar en qué puntos se desea realizar el cálculo.\

A continuación hay que crear un núcleo para realizar la transformación de las imágenes en pirámides multiescalares que permitan calcular el flujo óptico.\

   \begin{lstlisting}[language=C]

   Ipp32f kernel[5];
   Ipp16s kernel_16s[5];

   kernel[2] = 0.375f;
   kernel[1] = kernel[3] = 0.25f;
   kernel[0] = kernel[4] = 0.5f*(0.5f - 0.375f);

   ippsConvert_32f16s_Sfs(kernel, kernel_16s, 5, ippRndNear, -15);

   \end{lstlisting}

Ahora se procede a calcular las pirámides en base a las imágenes en blanco y negro.

   \begin{lstlisting}[language=C]

   IppiPyramid *pPyr1, *pPyr2;

   /*Crea las pirámides*/
   ippiPyramidInitAlloc (&pPyr1, num_capas, (IppiSize)tam_imagen,
                         (float)cambio_entre_pirámides);
   ippiPyramidInitAlloc (&pPyr2, num_capas, (IppiSize)tam_imagen,
                         (float)cambio_entre_pirámides);

   IppiPyramidDownState_8u_C1R **pState1;
   IppiPyramidDownState_8u_C1R **pState2;
   Ipp8u **pImg1 = pPyr1->pImage;
   Ipp8u **pImg2 = pPyr2->pImage;
   int *pStep1 = pPyr1->pStep;

   int *pStep2 = pPyr2->pStep;

   IppiSize *pRoi1 = pPyr1->pRoi;
   IppiSize *pRoi2 = pPyr2->pRoi;
   IppHintAlgorithm hint=ippAlgHintFast;
   int i,level = pPyr1->level;

   pState1 = (IppiPyramidDownState_8u_C1R**) & (pPyr1->pState);
   pState2 = (IppiPyramidDownState_8u_C1R**) & (pPyr2->pState);

   /*Rellenar cada capa reduciendo la imagen de la capa anterior*/
   ippiPyramidLayerDownInitAlloc_8u_C1R(pState1,roiSize,rate,
                                        pKernel,kerSize,IPPI_INTER_LINEAR);
   ippiPyramidLayerDownInitAlloc_8u_C1R(pState2,roiSize,rate,pKernel,
                                        kerSize,IPPI_INTER_LINEAR);
   pImg1[0] = (Ipp8u*)img_anterior_bn;
   pImg2[0] = (Ipp8u*)img_posterior_bn;
   pStep1[0] = prevStep;
   pStep2[0] = nextStep;
   pRoi1[0] = pRoi2[0] = roiSize;
   /*Se colocan las imágenes de cada capa en su lugar y se reserva nueva
      memoria para cada capa*/
   for (i=1; i<=capa; i++) {
      pPyr1->pImage[i] = ippiMalloc_8u_C1(pRoi1[i].width,
                                          pRoi1[i].height,pStep1+i);
      pPyr2->pImage[i] = ippiMalloc_8u_C1(pRoi2[i].width,pRoi2[i].height,
                                          pStep2+i);
      ippiPyramidLayerDown_8u_C1R(pImg1[i-1],pStep1[i-1],pRoi1[i-1],
                                  pImg1[i],pStep1[i],pRoi1[i],*pState1);
      ippiPyramidLayerDown_8u_C1R(pImg2[i-1],pStep2[i-1],pRoi2[i-1],
                                  pImg2[i],pStep2[i],pRoi2[i],*pState2);
      }

   \end{lstlisting}

Después se prealiza el cálculo del flujo óptico utlizando las pirámides que se acaban de crear. Después de este paso, se tendrá en ``prev'' y ``next'' el origen y el destino del flujo óptico, en ``error'' el error con el que ese flujo óptico está calculado, y en ``status'' la capa en la que se ha detenido el cálculo. Si el valor de ``status'' para un punto es distinto de ``0'', se ignorará el dato puesto que no está calculado sobre la imagen en su tamaño original, sino en capas superiores de la pirámide.\

   \begin{lstlisting}[language=C]

   //Estructura temporal necesaria
   IppiOptFlowPyrLK *pOF;
   IppiPoint_32f next[num_pto_interes];
   Ipp8s status[num_pto_interes];
   Ipp32f error[num_pto_interes];

   ippiOpticalFlowPyrLKInitAlloc_8u_C1R (&pOF,roiSize,winSize,hint);
   switch (ippiOpticalFlowPyrLK_8u_C1R (pPyr1,pPyr2,prev,next,status,
                                        error,numFeat,winSize,numLevel,
                                        numIter,threshold,pOF));

   \end{lstlisting}

Por último se libera el espacio reservado previamente.\

   \begin{lstlisting}[language=C]

   ippiOpticalFlowPyrLKFree_8u_C1R(pOF);
   for (i=n_niveles; i>0; i--) {

      if (pImg2[i]) ippiFree(pImg2[i]);

      if (pImg1[i]) ippiFree(pImg1[i]);

   }
   ippiPyramidLayerDownFree_8u_C1R(*pState1);
   ippiPyramidLayerDownFree_8u_C1R(*pState2);
   ippiPyramidFree (pPyr2);
   ippiPyramidFree (pPyr1);

   \end{lstlisting}

\end{document}


